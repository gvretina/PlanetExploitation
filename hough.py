#!/usr/bin/python3

import cv2
import numpy as np
import sys
import config
from copy import copy

#bgs_cnt = cv2.createBackgroundSubtractorMOG2()

def bgremove3(myimage):
    # First Convert to Grayscale
    myimage_grey = cv2.cvtColor(myimage, cv2.COLOR_BGR2GRAY)

    # Threshold the image to create a binary image
    _, foreground = cv2.threshold(myimage_grey, 127, 255, cv2.THRESH_BINARY_INV)

    # Invert the foreground mask to create a background mask
    background = cv2.bitwise_not(foreground)

    # Convert the masks to BGR
    foreground = cv2.cvtColor(foreground, cv2.COLOR_GRAY2BGR)
    background = cv2.cvtColor(background, cv2.COLOR_GRAY2BGR)

    # Bitwise-AND the masks with the original image
    foreground = cv2.bitwise_and(myimage,myimage, mask=foreground)
    background = cv2.bitwise_and(myimage,myimage, mask=background)

    # Combine the background and foreground to obtain our final image
    finalimage = cv2.add(background, foreground)

    return finalimage


def bgremove2(myimage):
    # First Convert to Grayscale
    #print(myimage.shape)
    myimage = cv2.GaussianBlur(myimage,config.Gaus_blur,0)
    myimage_grey = cv2.cvtColor(myimage, cv2.COLOR_BGR2GRAY)
    ret,baseline = cv2.threshold(myimage_grey,127,255,cv2.THRESH_TRUNC)

    ret,background = cv2.threshold(baseline,126,255,cv2.THRESH_BINARY)

    ret,foreground = cv2.threshold(baseline,126,255,cv2.THRESH_BINARY_INV)

    foreground = cv2.bitwise_and(myimage,myimage, mask=foreground)  # Update foreground with bitwise_and to extract real foreground

    result = cv2.bitwise_and(myimage, foreground)

    hsv_result = cv2.cvtColor(result, cv2.COLOR_BGR2HSV)

    #Take S and remove any value that is less than half
    s = hsv_result[:,:,1]
    s = np.where(s < 127, 0, 1) # Any value below 127 will be excluded

    # We increase the brightness of the image and then mod by 255
    v = (hsv_result[:,:,2] + 127) % 255
    v = np.where(v > 127, 1, 0)  # Any value above 127 will be part of our mask

    # Combine our two masks based on S and V into a single "Foreground"
    foreground = np.where(s+v > 0, 1, 0).astype(np.uint8)  #Casting back into 8bit integer
    result = cv2.bitwise_and(result,result,mask=foreground) # Apply our foreground map to original image

    return result#finalimage


def houghanalysis(frame_prev,frame_now):
    x = []
    frame_prev = cv2.cvtColor(frame_prev, cv2.COLOR_BGR2GRAY)
    frame_now = cv2.cvtColor(frame_now, cv2.COLOR_BGR2GRAY)

    ##### OPTION 1 ###### absolute frame difference
    dframe = cv2.absdiff(frame_now, frame_prev)
    #dframe=frame_now   ### to be able to see anything when not using script
    _, dframe = cv2.threshold(dframe, 15, 255, cv2.THRESH_BINARY)# + cv2.THRESH_OTSU)
    dframe = cv2.bitwise_not(dframe).astype("uint8")
    img = cv2.bitwise_and(frame_now,frame_now, mask=dframe)
    ##### OPTION 2 ###### CNT
    #fgMask = bgs_cnt.apply(frame_now)
    #img = cv2.bitwise_and(frame_now,frame_now, mask=fgMask)

    # do some processing on the grey scale image
    img = cv2.GaussianBlur(img,config.Gaus_blur,1.5,1.5)
    #cv2.Canny(frame_now, 5, 70, 3)
    img = cv2.medianBlur(img,config.median_blur)
    #cimg = copy(img)
    cimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)

    circles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,#_ALT,
                               config.Inverse_ratio, #1.5
                               config.min_dist,
                               param1=config.param1, #300
                               param2=config.param2, #0.8
                               minRadius=config.min_radius,
                               maxRadius=config.max_radius)
    try:
        circles = np.uint16(np.around(circles))
        y = []
        for i in circles[0,:]:
            mask = np.zeros_like(img)
            cv2.circle(mask,(i[0],i[1]),i[2],(255,255,255),-1) # draw the outer circle
            masked_image = cv2.bitwise_and(img, img, mask=mask)
            masked_image = masked_image/i[2]
            y = np.mean(masked_image)
            print(y)
            if y>7e-2:
                cv2.imshow("a",masked_image)
                continue

            cv2.circle(cimg,(i[0],i[1]),i[2],(0,255,0),1) # draw the outer circle
            cv2.circle(cimg,(i[0],i[1]),2,(0,0,255),3) # draw the center of the circle
            cv2.putText(cimg, f"{i[2]}", (i[0],i[1]),
                        fontFace = cv2.FONT_HERSHEY_COMPLEX,
                        fontScale = 1, color = (0,0,255))
            coord = (i[0], i[1])
            x.append(coord)
    except TypeError:
        pass
    return cimg, x

#def houghanalysis(img):
    #x = []
    ##session = new_session("silueta")
    ##img = remove(img,session=session)
    #img = bgremove2(img)
    #img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    #img = cv2.GaussianBlur(img,config.Gaus_blur,0)
    #img = cv2.medianBlur(img,config.median_blur)
    #cimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)
    #circles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,config.Inverse_ratio,config.min_dist,param1=config.param1,param2=config.param2,minRadius=config.min_radius,maxRadius=config.max_radius)
    #try:
        #circles = np.uint16(np.around(circles))
    
        #for i in circles[0,:]:
            #cv2.circle(cimg,(i[0],i[1]),i[2],(0,255,0),1) # draw the outer circle
            #cv2.circle(cimg,(i[0],i[1]),2,(0,0,255),3) # draw the center of the circle
            #cord = (i[0], i[1])
            #x.append(cord)
    #except TypeError:
        #pass
    #return cimg, x
